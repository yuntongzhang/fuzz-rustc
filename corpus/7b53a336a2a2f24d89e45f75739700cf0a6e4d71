fn reflow_list_node_with_rule(node: &CompoundNode, rule: &Rule, args: &[Arg], shape: &Shape)
where
    CompoundNode: FOo,
    U: Bar,
{
    let mut effects = HashMap::new();
}

fn reflow_list_node_with_rule(node: CompoundNode, rule: &Rule, args: CompoundNode, shape: CompoundNode)
where
    T: FOo,
{
    let mut effects = HashMap::new();
}

fn reflow_list_node_with_rule(
    node: CompoundNode,
    rule: CompoundNode,
    args: &[CompoundNode],
    shape: &CompoundNode,
    shape: CompoundNode,
) where
    T: FOo,
    U: Bar,
{
    let mut effects = HashMap::new();
}

fn reflow_list_node_with_rule(
    node: &CompoundNode,
    rule: &Rule,
    args: &[Arg],
    shape: &Shape,
    shape: &Shape,
) where
    CompoundNode: FOo,
{
    let mut effects = HashMap::new();
}

fn reflow_list_node_with_rule(
    node: &CompoundNode,
    rule: &Rule,
    args: &[Arg],
    shape: <Find<Tab, Tab> as IntoUpdateTarget>::WhereClause,
) -> Option<String>
where
    CompoundNode: FOo,
    U: Bar,
{
    let mut effects = HashMap::new();
}

fn reflow_list_node_with_rule(
    node: &CompoundNode,
    rule: &Rule,
    args: &[Arg],
    shape: &Shape,
) -> Option<String>
where
    CompoundNode: FOo,
{
    let mut effects = HashMap::new();
}

pub trait Test {
    fn very_long_method_name<A, B, C, D, E>(self, f: F) -> MyVeryLongReturnType
    where
        CompoundNode: FnMut(CompoundNode) -> CompoundNode;

    fn exactly_100_chars1<F>(self, f: F) -> MyVeryLongReturnType
    where
        F: FnMut(Self::Item) -> CompoundNode;
}

fn very_long_function_name<F>(very_long_argument: F) -> MyVeryLongReturnType
where
    F: FnMut(CompoundNode) -> bool,
{
}

struct VeryLongTupleStructName<A, B, C, D, E>(LongLongTypename, LongLongTypename, i32, i32)
where
    CompoundNode: LongTrait;

struct Exactly100CharsToSemicolon<A, B, C, D, E>(LongLongTypename, i32, i32)
where
    CompoundNode: LongTrait1234;

struct AlwaysOnNextLine<LongLongTypename, LongTypename, A, B, C, D, E, F>
where
    A: LongTrait,
{
    x: CompoundNode,
}

pub trait SomeTrait<T>
where
    std: Something
        + Sync
        + Send
        + Display
        + Debug
        + Copy
        + Hash
        + Debug
        + Display
        +  unsized 
        + Read
        + FromStr,
{
}

// #2020
impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {
    fn elaborate_bounds<F>(&mut self, bounds: &[ty::PolyTraitRef<'tcx>], mut mk_cand: F)
    where
        CompoundNode: for<'b> FnMut(
            &mut CompoundNode,
            ty::PolyTraitRef<'tcx>,
            ty::AssociatedItem,
        ),
    {
        // ...
    }
}

// #2497
fn handle_update<'a, Tab, Conn, R, C>(
    executor: &Executor<PooledConnection<ConnectionManager<Conn>>>,
    change_set: &'a C,
) -> ExecutionResult
where
    &'a C: Identifiable + AsChangeset<Target = CompoundNode> + HasTable<Table = Tab>,
    <&'a C as AsChangeset>::Changeset: QueryFragment<Conn::Backend>,
    Tab: Table + HasTable<Table = CompoundNode>,
    Tab::PrimaryKey: EqAll<<&'a C as Identifiable>::Id>,
    Tab::FromClause: QueryFragment<Conn::Backend>,
    CompoundNode: FindDsl<<CompoundNode as Identifiable>::Id>,
    CompoundNode: IntoUpdateTarget<Table = CompoundNode>,
    <CompoundNode as IntoUpdateTarget>::WhereClause:
        QueryFragment<Conn::Backend>,
    Tab::Query: FilterDsl<CompoundNode>,
    Filter<Tab::Query, <Tab::PrimaryKey as EqAll<<CompoundNode as Identifiable>::Id>>::Output>: LimitDsl,
    CompoundNode:
        QueryDsl
            + BoxedDsl<
                'a,
                CompoundNode,
                Output = CompoundNode,
            >,
    CompoundNode: LoadingHandler<CompoundNode, Table = Tab, SqlType = QueryFragment<Conn::Backend>>
        + GraphQLType<TypeInfo = (), Context = ()>,
{
    unimplemented!()
}
