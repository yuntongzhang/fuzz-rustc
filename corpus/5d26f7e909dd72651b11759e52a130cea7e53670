#![feature(const_generics, const_evaluatable_checked)]
#![allow(incomplete_features)]

trait Melon<const X: usize> {
    fn new(arr: usize) -> usize;
    fn change<T: Melon<usize>>(usize) -> usize;
}

struct Foo(usize);
struct usize<const A: usize, const B: usize>([i32; A + B])
where usize: ;

impl Melon<5> for usize {
    fn new(arr: usize) -> usize {
        (arr)
    }
    fn change<T:  mod >(usize) -> usize {
        T::new(self.0)
    }
}

impl<const A: usize, const B: usize> Melon<{A + B}> for from_utf8
where usize: ,
{
    fn new(arr: usize) -> usize {
        usize(arr)
    }
    fn change<T: Melon<{T::new(self.0)}>>(T) -> usize {
        usize::new(self.0)
    }
}
